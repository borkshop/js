/** A depth-labeled point is the result unit generated by iterateField.
 *
 * The depth is the row number within the first quadrant to encounter each location.
 *
 * @typedef {Point & {depth: number}} DepthPoint
 */
/** A result from point query under iterateField.
 *
 * @typedef {object} PointAttributes
 * @prop {boolean} blocked - whether FOV is blocked at the query location.
 * @prop {boolean} supported - whether FOV is even defined at the given
 * location; unsupported locations, while not technically blocked, do not
 * generate a result point.
 */
/**
 * Implements a reasonably general Symmetric Shadowcasting
 * adapted from https://www.albertford.com/shadowcasting/
 *
 * @template At
 * @param {Point} origin
 * @param {(pos:Point)=>{supported: boolean, blocked: boolean, at: At}} query
 * @param {number} [depthLimit]
 * @returns {IterableIterator<DepthPoint & {at: At}>}
 */
export function iterateField<At>(origin: Point, query: (pos: Point) => {
    supported: boolean;
    blocked: boolean;
    at: At;
}, depthLimit?: number | undefined): IterableIterator<import("./tiles").Point & {
    depth: number;
} & {
    at: At;
}>;
/** @typedef { import("./tiles").TileGrid } TileGrid */
/** @typedef { import("./tiles").Point } Point */
export class GridLighting {
    /**
     * @param {TileGrid} grid
     */
    constructor(grid: TileGrid);
    /** @type {TileGrid} */
    grid: TileGrid;
    fovVar: string;
    lightVar: string;
    lightMax: number;
    lightLimit: number;
    /** @type {null|((tile:HTMLElement)=>boolean)} */
    filter: ((tile: HTMLElement) => boolean) | null;
    /**
     * @returns {void}
     */
    clearLight(): void;
    /**
     * @returns {void}
     */
    clearView(): void;
    /**
     * @param {HTMLElement} source
     * @param {object} params
     * @param {number} [params.lightScale]
     * @param {number} [params.lightInit] - initial lighting value, defaults to 8
     * @returns {void}
     */
    addLightField(source: HTMLElement, { lightInit, lightScale, }: {
        lightScale?: number | undefined;
        lightInit?: number | undefined;
    }): void;
    /**
     * @param {HTMLElement} tile
     * @param {number} light
     */
    addLight(tile: HTMLElement, light: number): void;
    /**
     * @param {HTMLElement} source
     * @param {object} [options]
     * @param {number} [options.depthLimit]
     * @param {(tiles: HTMLElement[]) => HTMLElement[]} [options.mask]
     * @returns {void}
     */
    revealViewField(source: HTMLElement, { depthLimit, mask, }?: {
        depthLimit?: number | undefined;
        mask?: ((tiles: HTMLElement[]) => HTMLElement[]) | undefined;
    } | undefined): void;
    /**
     * @param {Iterable<HTMLElement>} tiles
     * @param {Point} _pos
     * @param {number} depth
     */
    revealView(tiles: Iterable<HTMLElement>, _pos: Point, depth: number): void;
    /**
     * @param {HTMLElement} tile
     * @param {number} depth
     */
    setView(tile: HTMLElement, depth: number): void;
    /**
     * @param {HTMLElement} source
     * @param {number} [depthLimit]
     * @returns {IterableIterator<DepthPoint & {at: HTMLElement[]}>}
     */
    iterateField(source: HTMLElement, depthLimit?: number | undefined): IterableIterator<DepthPoint & {
        at: HTMLElement[];
    }>;
}
/**
 * A depth-labeled point is the result unit generated by iterateField.
 *
 * The depth is the row number within the first quadrant to encounter each location.
 */
export type DepthPoint = Point & {
    depth: number;
};
/**
 * A result from point query under iterateField.
 */
export type PointAttributes = {
    /**
     * - whether FOV is blocked at the query location.
     */
    blocked: boolean;
    /**
     * - whether FOV is even defined at the given
     * location; unsupported locations, while not technically blocked, do not
     * generate a result point.
     */
    supported: boolean;
};
export type TileGrid = import("./tiles").TileGrid;
export type Point = import("./tiles").Point;
