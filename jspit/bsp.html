<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="index.css" />
    <title>jspit: BSP Procgen</title>
  </head>
  <body>

    <div class="grid">
      <noscript>
        <section>
          <h3 class="error">DOMgeoneering requires JavaScript</h3>
        </section>
      </noscript>
    </div>

    <aside class="menu">
      <button
        class="sticky"
        style="float: right; font-size: 1.5em; line-height: 1"
        data-keycode="Escape"
        title="<Esc>: Start/Stop Game ; Hide/Show Menu">☰</button>

      <button
        style="float: right; font-size: 1.5em; line-height: 1"
        data-keycode="Backspace"
        title="<BS>: Regenerate the world">♻</button>

      <label for="debug" style="float: right">
        <button
          style="font-size: 2em; line-height: 0.75"
          data-key="^"
          title="^: Toggle debug overlay">⌕</button>
        <input id="debug" type="checkbox" style="display: none">
      </label>

      <section>
        <h1>BSP Procgen</h1>
        <h3><a href="index.html">Back to Welcome screen</a></h3>

        <p>
          Primarily inspired by <a
            target="_blank"
            href="http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation"
            >Rogue Basin BSP article</a>.
          Demonstrates procedural dungeon generation within a random Binary
          Space Partitioning. This is still very much a WIP, and is roughly
          only "half done" (rooms, but no doors or hallways):
        </p>

        <ul>
          <li>the current scheme runs a BSP over the viewport bounds</li>
          <li>with a random chance (that increases with BSP tree depth) to
            place a room within a region; rooms may be no smaller than 4 units
            in either dimension, must have at least a 25-tile area, and at most
            108-tile area</li>
          <li>all of those constraint dimensions are wall-inclusive, so the
            minimum width/height of 4 means at least 2 floor tiles</li>
          <li>adjacent rooms have their shared walls simplified, granting
            more space to the smaller dimension, and placing a door randomly
            weighted towards the center</li>
          <li>(adjacent blocks of) rooms then have connective hallways added;
          this mostly works most of the time!</li>
        </ul>

        <p>Press <code>@</code> to play through the level; press <code>@</code>
        again if you get stuck to be respawned in a random room.</p>

        <p>Press <code>&lt;Backspace&gt;</code> to spin the RNG again and build
        a new world.</p>

        <p>Press <code>^</code> to toggle an overlay that shows the chosen
        binary tree regions.</p>

      </section>

      <fieldset id="inspector">
        <legend>
          <label for="inspector-ids">Tiles @<span data-for="pos">X,Y</span>:</label>
        </legend>
        <textarea readonly style="border: none; resize: none; user-select: all; width: 100%;"></textarea>
      </fieldset>

    </aside>

    <style>
      /* tile stacking priorities */
      .tile.floor { z-index:  1 }
      .tile       { z-index:  5 }
      .tile.wall  { z-index: 10 }
      .tile.mover { z-index: 20 }
      .tile.input { z-index: 50 }

      .grid { --grid-bg: hsl(0, 0, 0); }

      .plane { display: none }

      .grid:not(.playing) .plane[data-plane="solid"] { display: initial }
      .grid.playing .plane.meme { display: initial }

      .plane.meme .tile[data-light] { opacity: var(--light, 15%); }
      .plane.meme .tile:not([data-light]) { opacity: 15%; }

      .plane[data-plane="domgeon-inspect"] { display: initial }
      .plane[data-plane="domgeon-inspect"] { z-index: 1000 }

      .tile.floor { background-color: hsl(70, 5%, 12%); }
      .tile.wall { background-color: hsl(50, 15%, 15%); }
      .tile.door { background-color: hsl(50, 25%, 15%); }
      .tile.door.passable { background-color: hsl(70, 5%, 12%); }

      .tile.wall.mark {
        background-color: hsl(50, 30%, 30%);
        color: hsl(50, 90%, 60%);
      }

      .tile.floor { color: hsl(70, 5%, 27%); }
      .tile.wall { color: hsl(50, 25%, 30%); }
      .tile.mover { color: hsl(20, 75%, 50%); }
      .tile.mover.input,
      .tile.mover.inputable { color: hsl(220, 75%, 50%); }
      .tile.mover.input.focus,
      .tile.mover.inputable.focused { color: hsl(120, 75%, 50%); }
      .tile.door { color: hsl(50, 90%, 30%); }

      .tile.mover { --lightInit: 1; }
      .tile.mover.input { --lightInit: 2; }
      .tile.mover.input.focus { --lightInit: 8; }

      .tile.door { --action: "open"; --morph_target: "!passable"; }
      .tile.door.passable { --action: "close"; }

      .tile.door::before { content: "+" }
      .tile.door.passable::before { content: "-" }

      .tile.mover.support {
        text-decoration: underline;
        text-decoration-style: dotted;
      }

      .grid.debugging .plane[data-plane="debug"] { display: initial }
      .plane[data-plane="debug"] { z-index: 300 }
      .plane[data-plane="solid"] { z-index: 200 }

      .tile.box {
        z-index: calc(10 + var(--depth, 0));
        width: calc(var(--w) * var(--tile-height));
        height: calc(var(--h) * var(--tile-height));
        border: 0.2em solid hsl(calc(0 + var(--depth) * 47), 50%, 50%);
      }

    </style>

    <div class="buttonbar moves left"></div>
    <div class="buttonbar actions right float">
      <button data-key="@" title="Drop Player">@</button>
    </div>

    <script type="module">
      import {DOMgeon} from 'cdom/domgeon';
      const dmg = window.dmg = new DOMgeon({
        ui: document.body,
        keys: document.body,
        grid: document.querySelector('.grid'),
        moveBar: document.querySelector('.buttonbar.moves'),
        actionBar: document.querySelector('.buttonbar.actions'),
        lightLimit: 0.2,
      });

      document.getElementById('debug').addEventListener('change', (ev) => {
        dmg.grid.el.classList.toggle('debugging', !!ev.target.checked);
      });

      import {DOMgeonInspector} from 'cdom/domgeon';
      new DOMgeonInspector(dmg, document.querySelector('#inspector'));

      import * as build from 'cdom/builder';
      const floorShader = build.toShader({
        plane: 'solid',
        kind: 'floor',
        classList: ['support', 'passable'],
        text: '·',
      });
      const wallShader = build.toShader({
        plane: 'solid',
        kind: 'wall',
        text: '#',
      });
      const doorShader = build.toShader({
        plane: 'solid',
        kind: 'door',
        classList: 'interact',
      });
      const roomShader = build.roomShader({
        floors: (grid, pos, shape) => {
          floorShader(grid, pos, shape);
          const {x, y, w, h} = shape;
          if (pos.x === x + Math.floor(w/2) &&
              pos.y === y + Math.floor(h/2)) {
            const tile = grid.tileAt(pos, 'floor');
            if (tile) tile.classList.add('spawn');
          }
        },
        walls: wallShader,
      });

      const minRoomSize = {w: 4, h: 4};
      const minRoomArea = 25;
      const maxRoomArea = 108;

      import {
        shrinkRegion,
        tangent,
        adjacentPoints,
        connectionPoints,
        sideNormal,
        Side,
      } from './bsp';

      import {BSP} from 'cdom/procgen';

      const plane = 'solid';

      let lastSpawn = null;
      function chooseSpawn() {
        let spawn = null, bestScore = 0;
        for (const tile of dmg.grid.queryTiles({
          plane,
          className: 'spawn',
        })) {
          const pos = dmg.grid.getTilePosition(tile);
          if (pos.x === lastSpawn?.x && pos.y === lastSpawn?.y) continue;
          const score = Math.random();
          if (!spawn || bestScore < score)
            spawn = pos, bestScore = score;
        }
        lastSpawn = spawn;
        return spawn;
      }

      function dropPlayer() {
        let actor = dmg.grid.queryTile({plane: 'solid', className: ['input', 'focus', 'mover']});
        if (actor) {
          dmg.grid.moveTileTo(actor, chooseSpawn());
        } else {
          actor = dmg.grid.createTile({
            plane: 'solid',
            pos: chooseSpawn(),
            kind: 'mover',
            classList: ['input', 'focus'],
            text: '@',
          });
        }
        dmg.updateActorView(actor);
        dmg.grid.el.classList.toggle('playing', !!actor);
      }

      function* tilesAt(pos, kind) {
        // TODO tilesAt should require a plane, or be limited to one by a view
        for (const tile of dmg.grid.tilesAt(pos, kind))
          if (dmg.grid.getTilePlane(tile) === plane)
            yield tile;
      }

      function removeAt(pos, kind) {
        for (const tile of tilesAt(pos, kind))
          tile.parentNode?.removeChild(tile);
      }

      function doorAt(pos) {
        removeAt(pos, 'wall');
        doorShader(dmg.grid, pos);
      }

      function markAt(pos, kind, text) {
        for (const tile of tilesAt(pos, kind)) {
          tile.textContent = text;
          tile.classList.add('mark');
        }
      }

      function turnTo(dir, at, to) {
        if (dir.y !== 0 && at.y === to.y)
          return {y: 0, x: Math.sign(to.x - at.x)};
        if (dir.x !== 0 && at.x === to.x)
          return {x: 0, y: Math.sign(to.y - at.y)};
        return null;
      }

      function reset() {
        const playing = dmg.grid.el.classList.contains('playing');

        dmg.grid.clear();

        const bounds = dmg.grid.viewbox;
        dmg.grid.viewPoint = {
          x: bounds.x + bounds.w/2,
          y: bounds.y + bounds.h/2,
        };

        const interiorPoints = new Set();

        let regionID = 0;
        function makeRegion(region, kind, id) {
          if (typeof id !== 'number') id = ++regionID; // gen next (connect phase)
          else regionID = Math.max(id, regionID);      // given (fill phase)
          return {kind, id, ...region};
        }

        const res = BSP.run({
          bounds,
          fill: (region, id) => {
            const {x, y, w, h} = region;
            if (w < minRoomSize.w || h < minRoomSize.h) return null;

            const depth = Math.floor(Math.log2(id + 1));
            const box = dmg.grid.createTile({
              id: `bsp-box-${id}`,
              plane: 'debug',
              kind: 'box',
              pos: {x, y},
              data: {bspID: id, depth, w, h},
            });

            // increasing probability of stopping here and placing a room within
            // this region, starting once we get under max area, reaching 100%
            // certainty at min area.
            region = shrinkRegion(region, {a: minRoomArea, ...minRoomSize});
            const p = (maxRoomArea - region.w * region.h) / (maxRoomArea - minRoomArea);
            if (p < 0 || Math.random() >= p) return null;

            build.fillRect(dmg.grid, region, roomShader);
            box.classList.add('leaf');
            return [makeRegion(region, 'room', id)];
          },
          connect: (as, bs) => {
            if (as.length === 1 && bs.length > 1) {
              const tmp = as;
              as = bs;
              bs = tmp;
            }

            // simplify any shared walls, and add doors
            let connected = false;
            for (const b of bs) for (const a of as)
              for (const {t, o} of tangent(b, a)) if (o.n > 2) {
                // shrink overlap to never consider extreme points, since
                // erasing those walls could introduce unintended diagonal
                // freedoms
                o.o++, o.n -= 2;

                const dir = !!(t % 2); // true iff top/bottom
                const eraseCo = dir ? a.h < b.h : a.w < b.w; // erase from the smaller dimension
                let choice = null, doorScore = 0;
                for (const {co, p, ...pos} of adjacentPoints(t, o, b, a)) {
                  interiorPoints.add(`${pos.x},${pos.y}`);
                  if (co === eraseCo) {
                    removeAt(pos, 'wall');
                  } else {
                    // scale of [0, 100], quadratically peaking in the middle
                    const weight = Math.pow((0.5 - Math.abs(p - 0.5))/0.5*10, 2);
                    const score = weight ? Math.pow(Math.random(), 1/weight) : 0;
                    if (!choice || doorScore < score)
                      choice = pos, doorScore = score;
                  }
                }
                if (choice) {
                  doorAt(choice);
                  connected = true;
                }
              }

            if (!connected) {
              // find closest candidate wall points to form a hallway
              // TODO maybe do random weighting rather than hard "best candidate"?
              const cand = [];
              for (const a of as) for (const b of bs) for (const cp of connectionPoints(a, b, {
                pointFilter: ({x,y}) => !interiorPoints.has(`${x},${y}`),
              })) {
                const {ap, bp} = cp;
                const d = {x: bp.x - ap.x, y: bp.y - ap.y};
                const td = Math.abs(d.x) + Math.abs(d.y);
                cand.push({td, d, a, b, ...cp});
              }
              cand.sort(({td: atd}, {td: btd}) => atd - btd);
              for (const c of cand) {
                const {td, ap, bp} = c;

                /** @type {Rect[]} */
                const halls = [];
                /** @type {Rect|null} */
                let hall = null;

                let dir = sideNormal(ap.s);
                let at = {x: ap.x, y: ap.y};
                let sanity = td;
                let ok = true;
                while (ok) {
                  if (sanity--<0) {
                    ok = false;
                    break;
                  }

                  const newDir = turnTo(dir, at, bp);
                  if (newDir) {
                    if (hall) halls.push(hall)
                    hall = null, dir = newDir;
                  }

                  at.x += dir.x, at.y += dir.y;
                  if (at.x === bp.x && at.y === bp.y) {
                    if (hall) halls.push(hall);
                    break;
                  }

                  if (!dir.x && !dir.y) {
                    ok = false;
                    break;
                  }

                  // blocked by any present .tile:not(.passable) in hall region
                  // (floor or flanking walls)
                  for (const p of dir.y
                    ? [{x: at.x-1, y: at.y},   at, {x: at.x+1, y: at.y}]
                    : [{x: at.x,   y: at.y-1}, at, {x: at.x,   y: at.y+1}])
                    for (const present of tilesAt(p))
                      if (!present.classList.contains('passable')) {
                        ok = false;
                        break;
                      }

                  if (hall) hall.w += dir.x, hall.h += dir.y;
                  else hall = {...at, w: dir.x, h: dir.y};

                }
                if (!ok) continue;

                // TODO factor out some sort of procgen.HallBuilder
                // TODO rework this to be more like a Digger algo, or to place
                // expanded hall rectangles, and then simplify shared walls ala
                // the above
                for (let k=0; k<halls.length; k++) {
                  const hall = halls[k];

                  let {x, y, w, h} = hall;
                  if (h < 0) y += h + 1, h = -h;
                  if (w < 0) x += w + 1, w = -w;

                  /** @param {Point}
                   * @returns {Point[]} */
                  const section = h
                    ? ({x, y}) => [{x: x-1, y}, {x, y}, {x: x+1, y}]
                    : ({x, y}) => [{x, y: y-1}, {x, y}, {x, y: y+1}]

                  const n = w || h;
                  const dx = w ? 1 : 0, dy = h ? 1 : 0;

                  for (let i=0; i<n; i++, x += dx, y += dy) {
                    const ps = section({x, y});
                    for (let j=0; j<ps.length; j++) {
                      const p = ps[j];
                      floorShader(dmg.grid, p);
                      if (j === 0 || j === ps.length-1) wallShader(dmg.grid, p);
                      else removeAt(p, 'wall');
                    }
                  }

                  as.push(makeRegion(hall, 'hall'));
                }
                doorAt(ap);
                doorAt(bp);
                connected = true;
                break;
              }
            }

            return as.concat(bs);
          },
        });

        if (playing) dropPlayer();
      }

      dmg.onKey.byCode['Backspace'] = ({type}) => {
        if (type === 'keyup') reset();
      };
      dmg.onKey.byKey['@'] = ({type}) => {
        if (type === 'keyup') dropPlayer();
      };

      reset();

    </script>
  </body>

</html>
<!-- vim:set ts=2 sw=2 expandtab -->

