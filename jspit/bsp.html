<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="index.css" />
    <title>jspit: BSP Procgen</title>
  </head>
  <body>

    <div class="grid">
      <noscript>
        <section>
          <h3 class="error">DOMgeoneering requires JavaScript</h3>
        </section>
      </noscript>
    </div>

    <aside class="menu">
      <button
        class="sticky"
        style="float: right; font-size: 2em; line-height: 0.75"
        data-keycode="Escape"
        title="<Esc>: Start/Stop Game ; Hide/Show Menu">☰</button>

      <label for="debug" style="float: right">
        <button
          style="font-size: 2em; line-height: 0.75"
          data-key="^"
          title="^: Toggle debug overlay">⌕</button>
        <input id="debug" type="checkbox" style="display: none">
      </label>

      <section>
        <h1>BSP Procgen</h1>
        <h3><a href="index.html">Back to Welcome screen</a></h3>

        <p>
          Demonstrates procedural generation within a random Binary Space
          Partitioning. This is still very much a WIP, and is roughly only
          "half done" (rooms, but no doors or hallways):
        </p>

        <ul>

          <li>What's done:<ul>
            <li>the current scheme runs a BSP over the viewport bounds</li>
            <li>with a random chance (that increases with BSP tree depth) to
              place a room within a region; rooms may be no smaller than 4 units
              in either dimension, must have at least a 25-tile area, and at most
              108-tile area</li>
            <li>all of those constraint dimensions are wall-inclusive, so the
              minimum width/height of 4 means at least 2 floor tiles</li>
          </ul></li>

          <li>What's next:<ul>
            <li>rooms are currently completely disconnnected</li>
            <li>adjacent rooms should have shared-wall
              simplification/elimination/door addition</li>
            <li>non-adjacent sibling rooms (in the BSP tree) should have a
              connecting hallway added</li>
          </ul></li>

          <li>What's beyond:<ul>
            <li>the current approach is very oriented around: fill or sub-divide both regions
              defined by each splitting point, then reduce the tree up from its
              leaves, connecting all parts</li>
            <li>an alternate interpretation worth pursuing would be: start with
              a fully supported space (all floor tiles), descend by building a
              wall along each splitting axis, then ascend connectively
              similarly to the current void-filler approach</li>
          </ul></li>

        </ul>

      </section>

      <fieldset id="inspector">
        <legend>
          <label for="inspector-ids">Tiles @<span data-for="pos">X,Y</span>:</label>
        </legend>
        <textarea readonly style="border: none; resize: none; user-select: all; width: 100%;"></textarea>
      </fieldset>

    </aside>

    <style>
      /* tile stacking priorities */
      .tile.floor { z-index:  1 }
      .tile       { z-index:  5 }
      .tile.wall  { z-index: 10 }
      .tile.mover { z-index: 20 }
      .tile.input { z-index: 50 }

      .grid { --grid-bg: hsl(0, 0, 0); }

      .plane { display: none }

      .grid:not(.playing) .plane[data-plane="solid"] { display: initial }
      .grid.playing .plane.meme { display: initial }

      .plane.meme .tile[data-light] { opacity: var(--light, 15%); }
      .plane.meme .tile:not([data-light]) { opacity: 15%; }

      .plane[data-plane="domgeon-inspect"] { display: initial }
      .plane[data-plane="domgeon-inspect"] { z-index: 1000 }

      .tile.floor { background-color: hsl(70, 5%, 12%); }
      .tile.wall { background-color: hsl(50, 15%, 15%); }
      .tile.door { background-color: hsl(50, 25%, 15%); }
      .tile.door.passable { background-color: hsl(70, 5%, 12%); }

      .tile.wall.mark {
        background-color: hsl(50, 30%, 30%);
        color: hsl(50, 90%, 60%);
      }

      .tile.floor { color: hsl(70, 5%, 27%); }
      .tile.wall { color: hsl(50, 25%, 30%); }
      .tile.mover { color: hsl(20, 75%, 50%); }
      .tile.mover.input,
      .tile.mover.inputable { color: hsl(220, 75%, 50%); }
      .tile.mover.input.focus,
      .tile.mover.inputable.focused { color: hsl(120, 75%, 50%); }
      .tile.door { color: hsl(50, 90%, 30%); }

      .tile.mover { --lightInit: 1; }
      .tile.mover.input { --lightInit: 2; }
      .tile.mover.input.focus { --lightInit: 8; }

      .tile.door { --action: "open"; --morph_target: "!passable"; }
      .tile.door.passable { --action: "close"; }

      .tile.door::before { content: "+" }
      .tile.door.passable::before { content: "-" }

      .tile.mover.support {
        text-decoration: underline;
        text-decoration-style: dotted;
      }

      .grid.debugging .plane[data-plane="debug"] { display: initial }
      .plane[data-plane="debug"] { z-index: 300 }
      .plane[data-plane="solid"] { z-index: 200 }

      .tile.box {
        z-index: calc(10 + var(--depth, 0));
        width: calc(var(--w) * var(--tile-height));
        height: calc(var(--h) * var(--tile-height));
        border: 0.2em solid hsl(calc(0 + var(--depth) * 47), 50%, 50%);
      }

    </style>

    <div class="buttonbar moves left"></div>
    <div class="buttonbar actions right float"></div>

    <script type="module">
      import {DOMgeon} from 'cdom/domgeon';
      const dmg = window.dmg = new DOMgeon({
        ui: document.body,
        keys: document.body,
        grid: document.querySelector('.grid'),
        moveBar: document.querySelector('.buttonbar.moves'),
        actionBar: document.querySelector('.buttonbar.actions'),
        lightLimit: 0.2,
      });

      document.getElementById('debug').addEventListener('change', (ev) => {
        dmg.grid.el.classList.toggle('debugging', !!ev.target.checked);
      });

      import {DOMgeonInspector} from 'cdom/domgeon';
      new DOMgeonInspector(dmg, document.querySelector('#inspector'));

      import * as build from 'cdom/builder';
      const floorShader = {plane: 'solid', kind: 'floor', classList: ['support', 'passable'], text: '·'};
      const wallShader = {plane: 'solid', kind: 'wall', text: '#'};
      const doorShader = {plane: 'solid', kind: 'door', classList: 'interact'};
      const roomShader = build.roomShader({
        floors: floorShader,
        walls: wallShader,
      });

      const bounds = dmg.grid.viewbox;

      dmg.grid.viewPoint = {
        x: bounds.x + bounds.w/2,
        y: bounds.y + bounds.h/2,
      };

      const minRoomSize = {w: 4, h: 4};
      const minRoomArea = 25;
      const maxRoomArea = 108;

      import {
        shrinkRegion,
        tangent,
        adjacentPoints,
      } from './bsp';

      import {BSP} from 'cdom/procgen';
      const touches = new Set();
      const res = BSP.run({
        bounds,
        fill: (region, id) => {
          const {x, y, w, h} = region;
          if (w < minRoomSize.w || h < minRoomSize.h) return null;

          const depth = Math.floor(Math.log2(id + 1));
          const box = dmg.grid.createTile({
            id: `bsp-box-${id}`,
            plane: 'debug',
            kind: 'box',
            pos: {x, y},
            data: {bspID: id, depth, w, h},
          });

          // increasing probability of stopping here and placing a room within
          // this region, starting once we get under max area, reaching 100%
          // certainty at min area.
          region = shrinkRegion(region, {a: minRoomArea, ...minRoomSize});
          const p = (maxRoomArea - region.w * region.h) / (maxRoomArea - minRoomArea);
          if (p < 0 || Math.random() >= p) return null;

          build.fillRect(dmg.grid, region, roomShader);
          box.classList.add('leaf');
          return [{kind: 'room', id, ...region}];
        },
        connect: (as, bs) => {
          if (as.length === 1 && bs.length > 1) {
            const tmp = as;
            as = bs;
            bs = tmp;
          }

          const plane = 'solid';
          const kindAt = (pos, kind) => dmg.grid.tilesAt(pos, kind)
            .filter(t => dmg.grid.getTilePlane(t) === plane);
          const mark = (pos, text) => {
            for (const tile of kindAt(pos, 'wall')) {
              tile.textContent = text;
              tile.classList.add('mark');
            }
          };

          for (const b of bs) {

            // TODO if touching coalesce shared wall(s)
            for (const a of as)
              for (const {t, o} of tangent(b, a)) if (o.n > 2) {
                // shrink overlap to never consider extreme points, since
                // erasing those walls could introduce unintended diagonal
                // freedoms
                o.o++, o.n -= 2;

                const k = `${a.id};${b.id}`;
                const ck = `${b.id};${a.id}`;
                if (touches.has(k) || touches.has(ck)) continue;
                const n = touches.size;
                touches.add(k);

                // ASCII letters; uppercase for B lowercase for A
                const code = 0x01 + n;
                const bt = String.fromCharCode(code | 0x40);
                const at = String.fromCharCode(code | 0x60);

                for (const {co, ...pos} of adjacentPoints(t, o, b, a))
                  mark(pos, co ? at : bt);
              }

            // TODO if not touching add hallway(s) to nearest

            // TODO add door(s) w/ touching

            as.push(b);
          }
          return as;
        },
      });

      console.groupCollapsed(`BSP created ${res?.length} regions`);
      console.table(res);
      console.groupEnd();

    </script>
  </body>

</html>
<!-- vim:set ts=2 sw=2 expandtab -->

