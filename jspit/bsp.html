<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="index.css" />
    <title>jspit: BSP Procgen</title>
  </head>
  <body>

    <div class="grid">
      <noscript>
        <section>
          <h3 class="error">DOMgeoneering requires JavaScript</h3>
        </section>
      </noscript>
    </div>

    <aside class="menu">
      <button
        class="sticky"
        style="float: right; font-size: 1.5em; line-height: 1"
        data-keycode="Escape"
        title="<Esc>: Start/Stop Game ; Hide/Show Menu">☰</button>

      <button
        style="float: right; font-size: 1.5em; line-height: 1"
        data-keycode="Backspace"
        title="<BS>: Regenerate the world">♻</button>

      <label for="debug" style="float: right">
        <button
          style="font-size: 2em; line-height: 0.75"
          data-key="^"
          title="^: Toggle debug overlay">⌕</button>
        <input id="debug" type="checkbox" style="display: none">
      </label>

      <section>
        <h1>BSP Procgen</h1>
        <h3><a href="index.html">Back to Welcome screen</a></h3>

        <p>
          Primarily inspired by <a
            target="_blank"
            href="http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation"
            >Rogue Basin BSP article</a>.
          Demonstrates procedural dungeon generation within a random Binary
          Space Partitioning. This is still very much a WIP, and is roughly
          only "half done" (rooms, but no doors or hallways):
        </p>

        <ul>

          <li>the current scheme runs a BSP over the viewport bounds</li>
          <li>with a random chance (that increases with BSP tree depth) to
            place a room within a region; rooms may be no smaller than 4 units
            in either dimension, must have at least a 25-tile area, and at most
            108-tile area</li>
          <li>all of those constraint dimensions are wall-inclusive, so the
            minimum width/height of 4 means at least 2 floor tiles</li>
          <li>adjacent rooms have their shared walls simplified, granting
            more space to the smaller dimension, and placing a door randomly
            weighted towards the center</li>

          <li>TODO:<ul>
            <li>non-adjacent sibling rooms (in the BSP tree) should have a
              connecting hallway added</li>
            <li>Another approach entirely:<ul>
              <li>the current approach is very oriented around: fill or sub-divide both regions
                defined by each splitting point, then reduce the tree up from its
                leaves, connecting all parts</li>
              <li>an alternate interpretation worth pursuing would be: start with
                a fully supported space (all floor tiles), descend by building a
                wall along each splitting axis, then ascend connectively
                similarly to the current void-filler approach</li>
            </ul></li>
          </ul></li>

        </ul>

      </section>

      <fieldset id="inspector">
        <legend>
          <label for="inspector-ids">Tiles @<span data-for="pos">X,Y</span>:</label>
        </legend>
        <textarea readonly style="border: none; resize: none; user-select: all; width: 100%;"></textarea>
      </fieldset>

    </aside>

    <style>
      /* tile stacking priorities */
      .tile.floor { z-index:  1 }
      .tile       { z-index:  5 }
      .tile.wall  { z-index: 10 }
      .tile.mover { z-index: 20 }
      .tile.input { z-index: 50 }

      .grid { --grid-bg: hsl(0, 0, 0); }

      .plane { display: none }

      .grid:not(.playing) .plane[data-plane="solid"] { display: initial }
      .grid.playing .plane.meme { display: initial }

      .plane.meme .tile[data-light] { opacity: var(--light, 15%); }
      .plane.meme .tile:not([data-light]) { opacity: 15%; }

      .plane[data-plane="domgeon-inspect"] { display: initial }
      .plane[data-plane="domgeon-inspect"] { z-index: 1000 }

      .tile.floor { background-color: hsl(70, 5%, 12%); }
      .tile.wall { background-color: hsl(50, 15%, 15%); }
      .tile.door { background-color: hsl(50, 25%, 15%); }
      .tile.door.passable { background-color: hsl(70, 5%, 12%); }

      .tile.wall.mark {
        background-color: hsl(50, 30%, 30%);
        color: hsl(50, 90%, 60%);
      }

      .tile.floor { color: hsl(70, 5%, 27%); }
      .tile.wall { color: hsl(50, 25%, 30%); }
      .tile.mover { color: hsl(20, 75%, 50%); }
      .tile.mover.input,
      .tile.mover.inputable { color: hsl(220, 75%, 50%); }
      .tile.mover.input.focus,
      .tile.mover.inputable.focused { color: hsl(120, 75%, 50%); }
      .tile.door { color: hsl(50, 90%, 30%); }

      .tile.mover { --lightInit: 1; }
      .tile.mover.input { --lightInit: 2; }
      .tile.mover.input.focus { --lightInit: 8; }

      .tile.door { --action: "open"; --morph_target: "!passable"; }
      .tile.door.passable { --action: "close"; }

      .tile.door::before { content: "+" }
      .tile.door.passable::before { content: "-" }

      .tile.mover.support {
        text-decoration: underline;
        text-decoration-style: dotted;
      }

      .grid.debugging .plane[data-plane="debug"] { display: initial }
      .plane[data-plane="debug"] { z-index: 300 }
      .plane[data-plane="solid"] { z-index: 200 }

      .tile.box {
        z-index: calc(10 + var(--depth, 0));
        width: calc(var(--w) * var(--tile-height));
        height: calc(var(--h) * var(--tile-height));
        border: 0.2em solid hsl(calc(0 + var(--depth) * 47), 50%, 50%);
      }

    </style>

    <div class="buttonbar moves left"></div>
    <div class="buttonbar actions right float"></div>

    <script type="module">
      import {DOMgeon} from 'cdom/domgeon';
      const dmg = window.dmg = new DOMgeon({
        ui: document.body,
        keys: document.body,
        grid: document.querySelector('.grid'),
        moveBar: document.querySelector('.buttonbar.moves'),
        actionBar: document.querySelector('.buttonbar.actions'),
        lightLimit: 0.2,
      });

      document.getElementById('debug').addEventListener('change', (ev) => {
        dmg.grid.el.classList.toggle('debugging', !!ev.target.checked);
      });

      import {DOMgeonInspector} from 'cdom/domgeon';
      new DOMgeonInspector(dmg, document.querySelector('#inspector'));

      import * as build from 'cdom/builder';
      const floorShader = build.toShader({
        plane: 'solid',
        kind: 'floor',
        classList: ['support', 'passable'],
        text: '·',
      });
      const wallShader = build.toShader({
        plane: 'solid',
        kind: 'wall',
        text: '#',
      });
      const doorShader = build.toShader({
        plane: 'solid',
        kind: 'door',
        classList: 'interact',
      });
      const roomShader = build.roomShader({
        floors: floorShader,
        walls: wallShader,
      });

      const minRoomSize = {w: 4, h: 4};
      const minRoomArea = 25;
      const maxRoomArea = 108;

      import {
        shrinkRegion,
        tangent,
        adjacentPoints,
      } from './bsp';

      import {BSP} from 'cdom/procgen';

      const plane = 'solid';

      function* tilesAt(pos, kind) {
        // TODO tilesAt should require a plane, or be limited to one by a view
        for (const tile of dmg.grid.tilesAt(pos, kind))
          if (dmg.grid.getTilePlane(tile) === plane)
            yield tile;
      }

      function removeAt(pos, kind) {
        for (const tile of tilesAt(pos, kind))
          tile.parentNode?.removeChild(tile);
      }

      function doorAt(pos) {
        removeAt(pos, 'wall');
        doorShader(dmg.grid, pos);
      }

      function markAt(pos, kind, text) {
        for (const tile of tilesAt(pos, kind)) {
          tile.textContent = text;
          tile.classList.add('mark');
        }
      }

      function reset() {
        dmg.grid.clear();

        const bounds = dmg.grid.viewbox;
        dmg.grid.viewPoint = {
          x: bounds.x + bounds.w/2,
          y: bounds.y + bounds.h/2,
        };

        // old scheme for pair markers
        // const marks = new Map();
        // function marker(aid, bid) {
        //   const k = `${aid};${bid}`;
        //   const ck = `${bid};${aid}`;
        //   if (marks.has(k) || marks.has(ck)) return null;
        //   const n = marks.size;
        //   marks.set(k, n);
        //   // ASCII letters; uppercase for prime lowercase for co
        //   const code = 0x01 + n;
        //   const t   = String.fromCharCode(code | 0x40);
        //   const cot = String.fromCharCode(code | 0x60);
        //   return (pos, co) => markAt(pos, 'wall', co ? cot : t);
        // }

        const res = BSP.run({
          bounds,
          fill: (region, id) => {
            const {x, y, w, h} = region;
            if (w < minRoomSize.w || h < minRoomSize.h) return null;

            const depth = Math.floor(Math.log2(id + 1));
            const box = dmg.grid.createTile({
              id: `bsp-box-${id}`,
              plane: 'debug',
              kind: 'box',
              pos: {x, y},
              data: {bspID: id, depth, w, h},
            });

            // increasing probability of stopping here and placing a room within
            // this region, starting once we get under max area, reaching 100%
            // certainty at min area.
            region = shrinkRegion(region, {a: minRoomArea, ...minRoomSize});
            const p = (maxRoomArea - region.w * region.h) / (maxRoomArea - minRoomArea);
            if (p < 0 || Math.random() >= p) return null;

            build.fillRect(dmg.grid, region, roomShader);
            box.classList.add('leaf');
            return [{kind: 'room', id, ...region}];
          },
          connect: (as, bs) => {
            if (as.length === 1 && bs.length > 1) {
              const tmp = as;
              as = bs;
              bs = tmp;
            }

            // simplify any shared walls, and add doors
            let connected = false;
            for (const b of bs) for (const a of as)
              for (const {t, o} of tangent(b, a)) if (o.n > 2) {
                // shrink overlap to never consider extreme points, since
                // erasing those walls could introduce unintended diagonal
                // freedoms
                o.o++, o.n -= 2;

                const dir = !!(t % 2); // true iff top/bottom
                const eraseCo = dir ? a.h < b.h : a.w < b.w; // erase from the smaller dimension
                let choice = null, doorScore = 0;
                for (const {co, p, ...pos} of adjacentPoints(t, o, b, a))
                  if (co === eraseCo) {
                    removeAt(pos, 'wall');
                  } else {
                    // scale of [0, 100], quadratically peaking in the middle
                    const weight = Math.pow((0.5 - Math.abs(p - 0.5))/0.5*10, 2);
                    const score = weight ? Math.pow(Math.random(), 1/weight) : 0;
                    if (!choice || doorScore < score)
                      choice = pos, doorScore = score;
                  }
                if (choice) {
                  doorAt(choice);
                  connected = true;
                }
              }

            // TODO if not touching add hallway(s) to nearest

            return as.concat(bs);
          },
        });
      }

      dmg.onKey.byCode['Backspace'] = ({type}) => {
        if (type === 'keyup') reset();
      };
      reset();

    </script>
  </body>

</html>
<!-- vim:set ts=2 sw=2 expandtab -->

