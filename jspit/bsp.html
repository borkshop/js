<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="index.css" />
    <title>jspit: BSP Procgen</title>
  </head>
  <body>

    <div class="grid">
      <noscript>
        <section>
          <h3 class="error">DOMgeoneering requires JavaScript</h3>
        </section>
      </noscript>
    </div>

    <aside class="menu">
      <button
        class="sticky"
        style="float: right; font-size: 1.5em; line-height: 1"
        data-keycode="Escape"
        title="<Esc>: Start/Stop Game ; Hide/Show Menu">☰</button>

      <button
        style="float: right; font-size: 1.5em; line-height: 1"
        id="regenWorld"
        data-keycode="Backspace"
        title="<BS>: Regenerate the world">♻</button>

      <label for="debug" style="float: right">
        <button
          style="font-size: 2em; line-height: 0.75"
          data-key="^"
          title="^: Toggle debug overlay">⌕</button>
        <input id="debug" type="checkbox" style="display: none">
      </label>

      <section>
        <h1>BSP Procgen</h1>
        <h3><a href="index.html">Back to Welcome screen</a></h3>

        <p>
          Primarily inspired by <a
            target="_blank"
            href="http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation"
            >Rogue Basin BSP article</a>.
          Demonstrates procedural dungeon generation within a random Binary
          Space Partitioning. This is still very much a WIP, and is roughly
          only "half done" (rooms, but no doors or hallways):
        </p>

        <ul>
          <li>the current scheme runs a BSP over the viewport bounds</li>
          <li>with a random chance (that increases with BSP tree depth) to
            place a room within a region; rooms may be no smaller than 4 units
            in either dimension, must have at least a 25-tile area, and at most
            108-tile area</li>
          <li>all of those constraint dimensions are wall-inclusive, so the
            minimum width/height of 4 means at least 2 floor tiles</li>
          <li>adjacent rooms have their shared walls simplified, granting
            more space to the smaller dimension, and placing a door randomly
            weighted towards the center</li>
          <li>(adjacent blocks of) rooms then have connective hallways added;
          this mostly works most of the time!</li>
        </ul>

        <p>Press <code>@</code> to play through the level; press <code>@</code>
        again if you get stuck to be respawned in a random room.</p>

        <p>Press <code>&lt;Backspace&gt;</code> to spin the RNG again and build
        a new world.</p>

        <p>Press <code>^</code> to toggle an overlay that shows the chosen
        binary tree regions.</p>

      </section>

      <fieldset id="inspector">
        <legend>
          <label for="inspector-ids">Tiles @<span data-for="pos">X,Y</span>:</label>
        </legend>
        <textarea readonly style="border: none; resize: none; user-select: all; width: 100%;"></textarea>
      </fieldset>

    </aside>

    <style>
      /* tile stacking priorities */
      .tile.floor { z-index:  1 }
      .tile       { z-index:  5 }
      .tile.wall  { z-index: 10 }
      .tile.mover { z-index: 20 }
      .tile.input { z-index: 50 }

      .grid { --grid-bg: hsl(0, 0, 0); }

      .plane { display: none }

      .grid:not(.playing) .plane[data-plane="solid"] { display: initial }
      .grid.playing .plane.meme { display: initial }

      .plane.meme .tile[data-light] { opacity: var(--light, 15%); }
      .plane.meme .tile:not([data-light]) { opacity: 15%; }

      .plane[data-plane="domgeon-inspect"] { display: initial }
      .plane[data-plane="domgeon-inspect"] { z-index: 1000 }

      .tile.floor { background-color: hsl(70, 5%, 12%); }
      .tile.wall { background-color: hsl(50, 15%, 15%); }
      .tile.door { background-color: hsl(50, 25%, 15%); }
      .tile.door.passable { background-color: hsl(70, 5%, 12%); }

      .tile.wall.mark {
        background-color: hsl(50, 30%, 30%);
        color: hsl(50, 90%, 60%);
      }

      .tile.floor { color: hsl(70, 5%, 27%); }
      .tile.wall { color: hsl(50, 25%, 30%); }
      .tile.mover { color: hsl(20, 75%, 50%); }
      .tile.mover.input,
      .tile.mover.inputable { color: hsl(220, 75%, 50%); }
      .tile.mover.input.focus,
      .tile.mover.inputable.focused { color: hsl(120, 75%, 50%); }
      .tile.door { color: hsl(50, 90%, 30%); }

      .tile.mover { --lightInit: 1; }
      .tile.mover.input { --lightInit: 2; }
      .tile.mover.input.focus { --lightInit: 8; }

      .tile.door { --action: "open"; --morph_target: "!passable"; }
      .tile.door.passable { --action: "close"; }

      .tile.door::before { content: "+" }
      .tile.door.passable::before { content: "-" }

      .tile.mover.support {
        text-decoration: underline;
        text-decoration-style: dotted;
      }

      .grid.debugging .plane[data-plane="debug"] { display: initial }
      .plane[data-plane="debug"] { z-index: 300 }
      .plane[data-plane="solid"] { z-index: 200 }

      .tile.box {
        z-index: calc(10 + var(--depth, 0));
        width: calc(var(--w) * var(--tile-height));
        height: calc(var(--h) * var(--tile-height));
        border: 0.2em solid hsl(calc(0 + var(--depth) * 47), 50%, 50%);
      }

    </style>

    <div class="buttonbar moves left"></div>
    <div class="buttonbar actions right float">
      <button data-key="@" id="dropPlayer" title="Drop Player">@</button>
    </div>

    <script type="module" src="./bsp.js"></script>
  </body>

</html>
<!-- vim:set ts=2 sw=2 expandtab -->

